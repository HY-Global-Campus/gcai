/*
 * Azure OpenAI API
 *
 * Azure OpenAI APIs for completions and search
 *
 * The version of the OpenAPI document: 2024-05-01-preview
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// AzureCosmosDbChatExtensionParameters : Parameters to use when configuring Azure OpenAI On Your Data chat extensions when using Azure Cosmos DB for MongoDB vCore. The supported authentication type is ConnectionString.
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct AzureCosmosDbChatExtensionParameters {
    /// The configured top number of documents to feature for the configured query.
    #[serde(rename = "top_n_documents", skip_serializing_if = "Option::is_none")]
    pub top_n_documents: Option<i32>,
    /// Whether queries should be restricted to use of indexed data.
    #[serde(rename = "in_scope", skip_serializing_if = "Option::is_none")]
    pub in_scope: Option<bool>,
    /// The configured strictness of the search relevance filtering. The higher of strictness, the higher of the precision but lower recall of the answer.
    #[serde(rename = "strictness", skip_serializing_if = "Option::is_none")]
    pub strictness: Option<i32>,
    /// Give the model instructions about how it should behave and any context it should reference when generating a response. You can describe the assistant's personality and tell it how to format responses. There's a 100 token limit for it, and it counts against the overall token limit.
    #[serde(rename = "role_information", skip_serializing_if = "Option::is_none")]
    pub role_information: Option<String>,
    /// The max number of rewritten queries should be send to search provider for one user message. If not specified, the system will decide the number of queries to send.
    #[serde(rename = "max_search_queries", skip_serializing_if = "Option::is_none")]
    pub max_search_queries: Option<i32>,
    /// If specified as true, the system will allow partial search results to be used and the request fails if all the queries fail. If not specified, or specified as false, the request will fail if any search query fails.
    #[serde(rename = "allow_partial_result", skip_serializing_if = "Option::is_none")]
    pub allow_partial_result: Option<bool>,
    /// The included properties of the output context. If not specified, the default value is `citations` and `intent`.
    #[serde(rename = "include_contexts", skip_serializing_if = "Option::is_none")]
    pub include_contexts: Option<Vec<models::OnYourDataContextProperty>>,
    #[serde(rename = "authentication", skip_serializing_if = "Option::is_none")]
    pub authentication: Option<Box<models::OnYourDataAuthenticationOptions>>,
    /// The MongoDB vCore database name to use with Azure Cosmos DB.
    #[serde(rename = "database_name")]
    pub database_name: String,
    /// The name of the Azure Cosmos DB resource container.
    #[serde(rename = "container_name")]
    pub container_name: String,
    /// The MongoDB vCore index name to use with Azure Cosmos DB.
    #[serde(rename = "index_name")]
    pub index_name: String,
    #[serde(rename = "fields_mapping")]
    pub fields_mapping: Box<models::AzureCosmosDbFieldMappingOptions>,
    #[serde(rename = "embedding_dependency")]
    pub embedding_dependency: Box<models::OnYourDataVectorizationSource>,
}

impl AzureCosmosDbChatExtensionParameters {
    /// Parameters to use when configuring Azure OpenAI On Your Data chat extensions when using Azure Cosmos DB for MongoDB vCore. The supported authentication type is ConnectionString.
    pub fn new(database_name: String, container_name: String, index_name: String, fields_mapping: models::AzureCosmosDbFieldMappingOptions, embedding_dependency: models::OnYourDataVectorizationSource) -> AzureCosmosDbChatExtensionParameters {
        AzureCosmosDbChatExtensionParameters {
            top_n_documents: None,
            in_scope: None,
            strictness: None,
            role_information: None,
            max_search_queries: None,
            allow_partial_result: None,
            include_contexts: None,
            authentication: None,
            database_name,
            container_name,
            index_name,
            fields_mapping: Box::new(fields_mapping),
            embedding_dependency: Box::new(embedding_dependency),
        }
    }
}

